(take 26 (iterate (comp char inc int) \a))
(take 26 (iterate (comp str char inc int) \a))
(map str (take 26 (iterate (comp char inc int) \a)))
(take-while #(not= % "f") (map str (take 26 (iterate (comp char inc int) \a))))
(char "f")
(first "f")
(empty? {})
(def n {"a" {:edges []} "c" {:edges []}})
(def m (assoc n "d" "wow"))
m
(key m)
(vals m)
(first (vals m))
(every? #(contains? :edges) (vals n))
(every? #(contains? :edges %) (vals n))
(every? #(contains? % :edges) (vals n))
(every? #(contains? % :edges) (vals m))
(every? :edges (vals n))
(every? :edges (vals m))
(every? :edges {})
(def t {"a" {:edges #{}} "b" {:edges []}})
m
n
(every? vector? (map :edges (vals n)))
(every? vector? (map :edges (vals t)))
(every? vector? (map :edges (vals m)))
(conj [] 1 2 3)
(apply conj [] 1 2 3)
(apply conj [] [1 2 3])
(map #(assoc % :visited true) [])
(select-key {:a [] :b []} [:a])
(select-keys {:a [] :b []} [:a])
(filter :a (select-keys {:a [] :b []} [:a]))
(first (select-keys {:a [] :b []} [:a]))
(def n {"a" 1 "b" 2})
(n "a")
(apply conj [] ["a"])
(apply conj [] "a")
(apply conj [] "1)
(apply conj [] 1)
(concat [1 2] [3] nil)
(conj [1 2] [])
